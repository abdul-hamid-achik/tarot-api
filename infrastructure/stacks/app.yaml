resources:
  # Generate random Rails master key
  railsMasterKey:
    type: random:RandomPassword
    properties:
      length: 32
      special: false

  # ECR Repository for storing container images
  ecrRepository:
    type: aws:ecr:Repository
    properties:
      name: ${app_name}
      imageScanningConfiguration:
        scanOnPush: true
      tags:
        app: ${app_name}
        environment: ${env}
        managed-by: pulumi

  # ECS Cluster
  ecsCluster:
    type: aws:ecs:Cluster
    properties:
      name: "${app_name}-cluster-${env}"
      settings: 
        - name: "containerInsights"
          value: "enabled"
      tags:
        Name: "${app_name}-cluster-${env}"
        environment: ${env}
        managed-by: pulumi

  # CloudWatch Log Group for ECS
  ecsLogGroup:
    type: aws:cloudwatch:LogGroup
    properties:
      name: "/ecs/${app_name}-${env}"
      retentionInDays: 30
      tags:
        Name: "/ecs/${app_name}-${env}"
        environment: ${env}
        managed-by: pulumi

  # ECS Task Definition
  ecsTaskDefinition:
    type: aws:ecs:TaskDefinition
    properties:
      family: "${app_name}-task-${env}"
      cpu: "1024"  # 1 vCPU
      memory: "2048"  # 2 GB
      networkMode: "awsvpc"
      requiresCompatibilities: ["FARGATE"]
      executionRoleArn: ${ecsTaskExecutionRoleArn}
      taskRoleArn: ${ecsTaskRoleArn}
      containerDefinitions: |
        [
          {
            "name": "${app_name}-container",
            "image": "${ecrRepository.repositoryUrl}:latest",
            "essential": true,
            "cpu": 1024,
            "memory": 2048,
            "portMappings": [
              {
                "containerPort": 3000,
                "hostPort": 3000,
                "protocol": "tcp"
              }
            ],
            "environment": [
              {
                "name": "RAILS_ENV",
                "value": "${env}"
              },
              {
                "name": "RAILS_LOG_TO_STDOUT",
                "value": "true"
              },
              {
                "name": "APP_NAME",
                "value": "${app_name}"
              },
              {
                "name": "ENVIRONMENT",
                "value": "${env}"
              }
            ],
            "secrets": [
              {
                "name": "DB_PASSWORD",
                "valueFrom": "arn:aws:ssm:${aws:region}:${aws:accountId}:parameter/${env}/database_password"
              },
              {
                "name": "RAILS_MASTER_KEY",
                "valueFrom": "arn:aws:ssm:${aws:region}:${aws:accountId}:parameter/${env}/rails_master_key"
              }
            ],
            "logConfiguration": {
              "logDriver": "awslogs",
              "options": {
                "awslogs-group": "/ecs/${app_name}-${env}",
                "awslogs-region": "${aws:region}",
                "awslogs-stream-prefix": "ecs",
                "awslogs-create-group": "true"
              }
            },
            "healthCheck": {
              "command": [
                "CMD-SHELL",
                "curl -f http://localhost:3000/health || exit 1"
              ],
              "interval": 30,
              "timeout": 5,
              "retries": 3,
              "startPeriod": 60
            }
          }
        ]
      tags:
        Name: "${app_name}-task-${env}"
        environment: ${env}
        managed-by: pulumi

  # Store Rails master key in SSM Parameter Store
  railsMasterKeyParam:
    type: aws:ssm:Parameter
    properties:
      name: "/${env}/rails_master_key"
      type: "SecureString"
      value: ${railsMasterKey.result}
      description: "Rails master key for ${app_name}"
      tier: "Standard"
      tags:
        Name: "${app_name}-rails-master-key-${env}"
        environment: ${env}
        managed-by: pulumi

  # Application Load Balancer
  alb:
    type: aws:lb:LoadBalancer
    properties:
      name: "${app_name}-alb-${env}"
      internal: false
      loadBalancerType: "application"
      securityGroups: 
        - ${albSecurityGroupId}
      subnets: 
        - ${publicSubnetIds[0]}
        - ${publicSubnetIds[1]}
      enableDeletionProtection: ${env == "production" ? true : false}
      tags:
        Name: "${app_name}-alb-${env}"
        environment: ${env}
        managed-by: pulumi

  # HTTP Target Group
  httpTargetGroup:
    type: aws:lb:TargetGroup
    properties:
      name: "${app_name}-http-tg-${env}"
      port: 3000
      protocol: "HTTP"
      targetType: "ip"
      vpcId: ${vpcId}
      healthCheck:
        enabled: true
        path: "/health"
        port: "3000"
        protocol: "HTTP"
        healthyThreshold: 3
        unhealthyThreshold: 3
        timeout: 5
        interval: 30
        matcher: "200"
      tags:
        Name: "${app_name}-http-tg-${env}"
        environment: ${env}
        managed-by: pulumi

  # HTTP Listener (Redirect to HTTPS)
  httpListener:
    type: aws:lb:Listener
    properties:
      loadBalancerArn: ${alb.arn}
      port: 80
      protocol: "HTTP"
      defaultActions:
        - type: "redirect"
          redirect:
            port: "443"
            protocol: "HTTPS"
            statusCode: "HTTP_301"

  # ACM Certificate
  acmCertificate:
    type: aws:acm:Certificate
    properties:
      domainName: "${env == "production" ? domain_name : "${env}.${domain_name}"}"
      validationMethod: "DNS"
      tags:
        Name: "${app_name}-cert-${env}"
        environment: ${env}
        managed-by: pulumi

  # HTTPS Listener
  httpsListener:
    type: aws:lb:Listener
    properties:
      loadBalancerArn: ${alb.arn}
      port: 443
      protocol: "HTTPS"
      sslPolicy: "ELBSecurityPolicy-TLS13-1-2-2021-06"
      certificateArn: ${acmCertificate.arn}
      defaultActions:
        - type: "forward"
          targetGroupArn: ${httpTargetGroup.arn}

  # Route 53 Hosted Zone (Comment out if zone already exists)
  hostedZone:
    type: aws:route53:Zone
    properties:
      name: ${domain_name}
      comment: "Managed by Pulumi for ${app_name}"
      tags:
        Name: "${app_name}-zone-${env}"
        environment: ${env}
        managed-by: pulumi

  # Certificate Validation Record
  acmValidationRecord:
    type: aws:route53:Record
    properties:
      zoneId: ${hostedZone.zoneId}
      name: ${acmCertificate.domainValidationOptions[0].resourceRecordName}
      type: ${acmCertificate.domainValidationOptions[0].resourceRecordType}
      records: 
        - ${acmCertificate.domainValidationOptions[0].resourceRecordValue}
      ttl: 60

  # Certificate Validation
  acmCertificateValidation:
    type: aws:acm:CertificateValidation
    properties:
      certificateArn: ${acmCertificate.arn}
      validationRecordFqdns: 
        - ${acmValidationRecord.fqdn}

  # DNS Record for Application
  dnsRecord:
    type: aws:route53:Record
    properties:
      zoneId: ${hostedZone.zoneId}
      name: "${env == "production" ? domain_name : "${env}.${domain_name}"}"
      type: "A"
      aliases:
        - name: ${alb.dnsName}
          zoneId: ${alb.zoneId}
          evaluateTargetHealth: true

  # ECS Service
  ecsService:
    type: aws:ecs:Service
    properties:
      name: "${app_name}-service-${env}"
      cluster: ${ecsCluster.arn}
      taskDefinition: ${ecsTaskDefinition.arn}
      desiredCount: 2
      launchType: "FARGATE"
      platformVersion: "LATEST"
      deploymentController:
        type: "ECS"
      deploymentMaximumPercent: 200
      deploymentMinimumHealthyPercent: 100
      networkConfiguration:
        subnets: 
          - ${privateSubnetIds[0]}
          - ${privateSubnetIds[1]}
        securityGroups: 
          - ${appSecurityGroupId}
        assignPublicIp: false
      loadBalancers:
        - targetGroupArn: ${httpTargetGroup.arn}
          containerName: "${app_name}-container"
          containerPort: 3000
      healthCheckGracePeriodSeconds: 60
      propagateTags: "SERVICE"
      tags:
        Name: "${app_name}-service-${env}"
        environment: ${env}
        managed-by: pulumi
      dependsOn:
        - ${acmCertificateValidation}

  # Auto Scaling Target
  autoScalingTarget:
    type: aws:appautoscaling:Target
    properties:
      maxCapacity: 4
      minCapacity: 2
      resourceId: "service/${ecsCluster.name}/${ecsService.name}"
      scalableDimension: "ecs:service:DesiredCount"
      serviceNamespace: "ecs"

  # CPU Auto Scaling Policy
  cpuScalingPolicy:
    type: aws:appautoscaling:Policy
    properties:
      name: "${app_name}-cpu-scaling-policy-${env}"
      policyType: "TargetTrackingScaling"
      resourceId: ${autoScalingTarget.resourceId}
      scalableDimension: ${autoScalingTarget.scalableDimension}
      serviceNamespace: ${autoScalingTarget.serviceNamespace}
      targetTrackingScalingPolicyConfiguration:
        predefinedMetricSpecification:
          predefinedMetricType: "ECSServiceAverageCPUUtilization"
        targetValue: 70.0
        scaleInCooldown: 300
        scaleOutCooldown: 60

  # Memory Auto Scaling Policy
  memoryScalingPolicy:
    type: aws:appautoscaling:Policy
    properties:
      name: "${app_name}-memory-scaling-policy-${env}"
      policyType: "TargetTrackingScaling"
      resourceId: ${autoScalingTarget.resourceId}
      scalableDimension: ${autoScalingTarget.scalableDimension}
      serviceNamespace: ${autoScalingTarget.serviceNamespace}
      targetTrackingScalingPolicyConfiguration:
        predefinedMetricSpecification:
          predefinedMetricType: "ECSServiceAverageMemoryUtilization"
        targetValue: 70.0
        scaleInCooldown: 300
        scaleOutCooldown: 60

outputs:
  ecrRepositoryUrl:
    value: ${ecrRepository.repositoryUrl}
  ecsClusterName:
    value: ${ecsCluster.name}
  ecsServiceName:
    value: ${ecsService.name}
  apiUrl:
    value: "https://${env == "production" ? domain_name : "${env}.${domain_name}"}"
  albDnsName:
    value: ${alb.dnsName} 